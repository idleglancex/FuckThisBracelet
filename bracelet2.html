<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pandora 3D: Master Control</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #FADADD 0%, #E6C2C2 70%, #7acce8 120%);
            font-family: 'Segoe UI', sans-serif;
            color: #1A1A1A;
            user-select: none;
        }

        /* Y√úKLEME EKRANI */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 50px;
            border-radius: 16px;
            text-align: center;
            border: 1px solid rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.1);
            transition: opacity 0.5s;
            z-index: 10;
        }

        #msg {
            font-size: 15px;
            letter-spacing: 0.5px;
            color: #444;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #007AFF;
            animation: spin 0.8s ease-in-out infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* KONTROL PANELƒ∞ */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 240px;
            background: rgba(255, 255, 255, 0.90);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            color: #333;
            font-size: 13px;
            z-index: 5;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.6);
            max-height: 90vh;
            overflow-y: auto;
        }

        .section-title {
            font-weight: 800;
            font-size: 11px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 3px;
        }

        /* Stil Se√ßici */
        .style-group {
            display: flex;
            gap: 15px;
            margin-bottom: 5px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        .radio-label input {
            accent-color: #007AFF;
            cursor: pointer;
        }

        /* Sliderlar */
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .slider-row label {
            font-weight: bold;
            width: 25px;
            color: #444;
        }

        .slider-row input {
            flex: 1;
            cursor: pointer;
            accent-color: #333;
            height: 4px;
            margin: 0 10px;
        }

        .slider-val {
            width: 35px;
            text-align: right;
            font-family: monospace;
            font-size: 11px;
            color: #666;
        }

        #footer {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.4);
            pointer-events: none;
            font-weight: bold;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <!-- KONTROL PANELƒ∞ -->
    <div id="controls">

        <!-- 1. G√∂r√ºn√ºm Modu -->
        <div>
            <div class="section-title">G√∂r√ºn√ºm Modu</div>
            <div class="style-group">
                <label class="radio-label">
                    <input type="radio" name="style" value="bright" checked onchange="switchStyle('bright')">
                    Bright
                </label>
                <label class="radio-label">
                    <input type="radio" name="style" value="metal" onchange="switchStyle('metal')">
                    Metal
                </label>
            </div>
        </div>



        <!-- 4. Se√ßili Charm Kontrol√º -->
        <div id="charm-controls"
            style="border-top: 1px solid #ddd; padding-top: 10px; margin-top: 5px; opacity: 0.5; pointer-events: none;">
            <div class="section-title" style="color:#E91E63">Se√ßili Charm Ayarlarƒ±</div>

            <div style="font-size:10px; color:#888; margin-bottom:5px; font-style:italic;" id="selected-charm-name">
                (Bir charm se√ßin)
            </div>

            <!-- Charm Rotasyon -->
            <div class="section-title">Charm D√∂nd√ºr</div>
            <div class="slider-group">
                <div class="slider-row">
                    <label>X</label>
                    <input type="range" min="-180" max="180" value="0"
                        oninput="updateSelectedCharmRotation('x', this.value)">
                    <span id="c-rot-val-x" class="slider-val">0¬∞</span>
                </div>
                <div class="slider-row">
                    <label>Y</label>
                    <input type="range" min="-180" max="180" value="0"
                        oninput="updateSelectedCharmRotation('y', this.value)">
                    <span id="c-rot-val-y" class="slider-val">0¬∞</span>
                </div>
                <div class="slider-row">
                    <label>Z</label>
                    <input type="range" min="-180" max="180" value="0"
                        oninput="updateSelectedCharmRotation('z', this.value)">
                    <span id="c-rot-val-z" class="slider-val">0¬∞</span>
                </div>
            </div>

            <!-- Charm Konum -->
            <div class="section-title" style="margin-top:5px;">Charm Kaydƒ±r</div>
            <div class="slider-group">
                <div class="slider-row">
                    <label>X</label>
                    <input type="range" min="-20" max="20" step="0.05" value="0"
                        oninput="updateSelectedCharmPosition('x', this.value)">
                    <span id="c-pos-val-x" class="slider-val">0</span>
                </div>
                <div class="slider-row">
                    <label>Y</label>
                    <input type="range" min="-20" max="20" step="0.05" value="0"
                        oninput="updateSelectedCharmPosition('y', this.value)">
                    <span id="c-pos-val-y" class="slider-val">0</span>
                </div>
                <div class="slider-row">
                    <label>Z</label>
                    <input type="range" min="-20" max="20" step="0.05" value="0"
                        oninput="updateSelectedCharmPosition('z', this.value)">
                    <span id="c-pos-val-z" class="slider-val">0</span>
                </div>
            </div>

            <button onclick="deleteSelectedCharm()"
                style="width:100%; background:#ff4444; color:white; border:none; padding:8px; border-radius:4px; margin-top:10px; cursor:pointer; font-size:11px; font-weight:bold;">
                üóëÔ∏è Sƒ∞L / DELETE
            </button>
        </div>

    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div id="msg">AT√ñLYE HAZIRLANIYOR...</div>
    </div>

    <div id="footer">PANDORA 3D VIEWER</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // --- AYARLAR ---
        const CHARM_FOLDER = './source/';
        const BRACE_OBJ = './brace.obj';
        const BRACELET_RADIUS = 3.8;
        const CHARM_SCALE = 2.5;
        const SKY_COLOR = 0xFFF0F5;

        // --- GLOBAL STATE ---
        const allCharmMeshes = [];
        let selectedCharm = null;

        // --- SAHNE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(SKY_COLOR);
        scene.fog = new THREE.Fog(SKY_COLOR, 15, 60);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 14);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- SELECTION SETUP ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectionBox = new THREE.BoxHelper(new THREE.Mesh(), 0xffff00);
        selectionBox.visible = false;
        scene.add(selectionBox);

        // --- I≈ûIKLAR ---
        const lights = { bright: [], metal: [] };

        // Bright Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0);
        hemiLight.position.set(0, 20, 0);
        lights.bright.push(hemiLight);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        lights.bright.push(dirLight);
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xffeedd, 1.5);
        fillLight.position.set(-5, 5, -5);
        lights.bright.push(fillLight);
        scene.add(fillLight);

        const spotLight = new THREE.SpotLight(0xffffff, 20);
        spotLight.position.set(5, 15, 5);
        spotLight.castShadow = true;
        spotLight.visible = false;
        lights.metal.push(spotLight);
        scene.add(spotLight);

        const rimLight = new THREE.DirectionalLight(0xccddff, 2);
        rimLight.position.set(-5, 2, -10);
        rimLight.visible = false;
        lights.metal.push(rimLight);
        scene.add(rimLight);

        const ambientMetal = new THREE.AmbientLight(0xffffff, 0.2);
        ambientMetal.visible = false;
        lights.metal.push(ambientMetal);
        scene.add(ambientMetal);

        // --- GRUPLAR ---
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        const braceletGroup = new THREE.Group();
        mainGroup.add(braceletGroup);
        const charmsGroup = new THREE.Group();
        braceletGroup.add(charmsGroup);

        const plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.2, color: 0x000000 }));
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -2.5;
        plane.receiveShadow = true;
        mainGroup.add(plane);

        const loaders = { obj: new OBJLoader(), gltf: new GLTFLoader(), fbx: new FBXLoader() };
        const uiMsg = document.getElementById('msg');
        const uiLoading = document.getElementById('loading');

        // --- FONKSƒ∞YONLAR ---

        // INDIVIDUAL SELECTION & CONTROL
        window.updateSelectedCharmRotation = function (axis, value) {
            if (!selectedCharm) return;
            const rad = THREE.MathUtils.degToRad(parseFloat(value));

            if (axis === 'x') selectedCharm.rotation.x = rad;
            if (axis === 'y') selectedCharm.rotation.y = rad;
            if (axis === 'z') selectedCharm.rotation.z = rad;

            document.getElementById(`c-rot-val-${axis}`).innerText = value + "¬∞";
            selectionBox.update();
        };

        window.updateSelectedCharmPosition = function (axis, value) {
            if (!selectedCharm) return;
            const val = parseFloat(value);

            // X corresponds to moving ALONG the bracelet (if we wanted that)
            // But here, selectedCharm is the model inside the holder.
            // Moving X/Y/Z moves it relative to the "bead hole".

            if (axis === 'x') selectedCharm.position.x = val;
            if (axis === 'y') selectedCharm.position.y = val;
            if (axis === 'z') selectedCharm.position.z = val;

            document.getElementById(`c-pos-val-${axis}`).innerText = val;
            selectionBox.update();
        };

        window.selectCharm = function (object) {
            // Find the top-level group for this charm inside 'charmsGroup'
            // The structure is charmsGroup -> pivot -> holder -> mesh
            // Wait, logic says: 
            // pivot.add(holder); holder.add(model);

            // So if we click the model, we want to select IT.

            let targetMesh = null;
            object.traverseAncestors((ancestor) => {
                if (allCharmMeshes.includes(ancestor)) targetMesh = ancestor;
            });
            if (allCharmMeshes.includes(object)) targetMesh = object;

            if (targetMesh) {
                selectedCharm = targetMesh;

                // Show Highlight
                selectionBox.setFromObject(selectedCharm);
                selectionBox.visible = true;

                // Enable UI
                const ui = document.getElementById('charm-controls');
                ui.style.opacity = '1';
                ui.style.pointerEvents = 'auto';

                // Update UI values
                document.getElementById('selected-charm-name').innerText = selectedCharm.userData.filename || "Charm";

                // Update sliders to match current state
                document.getElementById('c-rot-val-x').innerText = Math.round(THREE.MathUtils.radToDeg(selectedCharm.rotation.x)) + "¬∞";
                document.getElementById('c-rot-val-y').innerText = Math.round(THREE.MathUtils.radToDeg(selectedCharm.rotation.y)) + "¬∞";
                document.getElementById('c-rot-val-z').innerText = Math.round(THREE.MathUtils.radToDeg(selectedCharm.rotation.z)) + "¬∞";

                // Set slider input values
                document.querySelector('input[oninput="updateSelectedCharmRotation(\'x\', this.value)"]').value = Math.round(THREE.MathUtils.radToDeg(selectedCharm.rotation.x));
                document.querySelector('input[oninput="updateSelectedCharmRotation(\'y\', this.value)"]').value = Math.round(THREE.MathUtils.radToDeg(selectedCharm.rotation.y));
                document.querySelector('input[oninput="updateSelectedCharmRotation(\'z\', this.value)"]').value = Math.round(THREE.MathUtils.radToDeg(selectedCharm.rotation.z));

                document.getElementById('c-pos-val-x').innerText = selectedCharm.position.x.toFixed(2);
                document.getElementById('c-pos-val-y').innerText = selectedCharm.position.y.toFixed(2);
                document.getElementById('c-pos-val-z').innerText = selectedCharm.position.z.toFixed(2);

                document.querySelector('input[oninput="updateSelectedCharmPosition(\'x\', this.value)"]').value = selectedCharm.position.x;
                document.querySelector('input[oninput="updateSelectedCharmPosition(\'y\', this.value)"]').value = selectedCharm.position.y;
                document.querySelector('input[oninput="updateSelectedCharmPosition(\'z\', this.value)"]').value = selectedCharm.position.z;


                // Stop global auto-rotate to focus
                controls.autoRotate = false;
            } else {
                deselectCharm();
            }
        };

        function deselectCharm() {
            selectedCharm = null;
            selectionBox.visible = false;
            const ui = document.getElementById('charm-controls');
            ui.style.opacity = '0.5';
            ui.style.pointerEvents = 'none';
            document.getElementById('selected-charm-name').innerText = "(Bir charm se√ßin)";
            controls.autoRotate = true;
        }
        window.deleteSelectedCharm = async function () {
            if (!selectedCharm) return;
            if (!confirm("Are you sure you want to delete this charm?")) return;

            const filename = selectedCharm.userData.filename;
            const isLocal = selectedCharm.userData.isLocal;
            const localId = selectedCharm.userData.localId;

            try {
                if (isLocal && localId) {
                    await deleteCharmFromDB(localId);
                } else {
                    await fetch(`/api/delete?filename=${filename}`, { method: 'DELETE' });
                }

                const pivot = selectedCharm.parent;
                pivot.remove(selectedCharm);
                charmsGroup.remove(pivot);

                const idx = allCharmMeshes.indexOf(selectedCharm);
                if (idx > -1) allCharmMeshes.splice(idx, 1);

                deselectCharm();
            } catch (e) {
                console.error(e);
                alert("Charm removed from scene, but storage delete might have failed.");

                const pivot = selectedCharm.parent;
                if (pivot) {
                    pivot.remove(selectedCharm);
                    charmsGroup.remove(pivot);
                }
                const idx = allCharmMeshes.indexOf(selectedCharm);
                if (idx > -1) allCharmMeshes.splice(idx, 1);
                deselectCharm();
            }
        };

        window.addEventListener('mousedown', (event) => {
            if (event.target.closest('#controls') || event.target.closest('#charm-controls')) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(charmsGroup.children, true);

            if (intersects.length > 0) {
                window.selectCharm(intersects[0].object);
            }
        });

        function loadModelSmart(url) {
            return new Promise((resolve) => {
                console.log("Loading Smart:", url);
                const ext = url.split('.').pop().toLowerCase();
                const loader = (ext === 'fbx') ? loaders.fbx : (ext === 'obj' ? loaders.obj : loaders.gltf);

                loader.load(url, (data) => {
                    let model = data.scene || data;

                    // Force clean material to avoid visual glitches or 404s on missing textures
                    const cleanMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        metalness: 0.4,
                        roughness: 0.5
                    });

                    model.traverse(c => {
                        if (c.isMesh) {
                            c.castShadow = true;
                            c.receiveShadow = true;
                            // Completely replace material to ensure visibility and prevent 404s on textures
                            c.material = cleanMaterial;
                        }
                    });

                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    console.log(`Loaded ${url}: Size`, size);

                    if (Math.max(size.x, size.y, size.z) > 0) {
                        const scale = CHARM_SCALE / Math.max(size.x, size.y, size.z);
                        console.log(`Applying Scale: ${scale} to ${url}`);
                        model.scale.set(scale, scale, scale);

                        // Recalculate center after scaling? No, logic was:
                        // model.position.sub(center * scale)
                        const center = new THREE.Box3().setFromObject(model).getCenter(new THREE.Vector3());
                        // We want to center it at 0,0,0
                        model.position.sub(center);

                        // Align bottom to 0? 
                        // model.position.y -= ... 
                        // Actually, let's just Center it on Y too for the "Holder" logic.
                        // If it sits in a bead holder, centering is usually safer.
                    }

                    resolve(model);
                }, undefined, (err) => {
                    console.error("Error loading " + url, err);
                    resolve(null);
                });
            });
        }

        // --- DATABASE FUNCTIONS ---
        const STORE_NAME = 'charms';
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('PandoraDB', 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        async function getCharmsFromDB() {
            try {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const store = tx.objectStore(STORE_NAME);
                    const req = store.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.error("DB Error:", e);
                return [];
            }
        }

        async function deleteCharmFromDB(id) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const req = store.delete(id);
                req.onsuccess = () => resolve();
                req.onerror = () => reject(req.error);
            });
        }

        // --- CONTENT LOADING ---
        async function loadMainBracelet() {
            return new Promise((resolve, reject) => {
                loaders.obj.load(BRACE_OBJ, (obj) => {
                    obj.scale.set(1.0, 1.0, 1.0); // Converted 1.5 -> 1.0
                    obj.rotation.x = Math.PI / 2;
                    obj.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xC0C0C0,
                                metalness: 0.9,
                                roughness: 0.1
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    const box = new THREE.Box3().setFromObject(obj);
                    const center = box.getCenter(new THREE.Vector3());
                    obj.position.sub(center);
                    braceletGroup.add(obj);
                    resolve(obj);
                }, undefined, (err) => {
                    console.error("Brace load error:", err);
                    const geometry = new THREE.TorusGeometry(3.5, 0.1, 16, 100);
                    const material = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.9, roughness: 0.1 });
                    const torus = new THREE.Mesh(geometry, material);
                    torus.rotation.x = Math.PI / 2;
                    braceletGroup.add(torus);
                    resolve(torus);
                });
            });
        }

        async function scanSourceFolder() {
            try {
                const response = await fetch('/api/list');
                if (!response.ok) throw new Error('List API failed');
                const files = await response.json();
                return files;
            } catch (error) {
                console.warn("Could not load static charms via API, trying fallback...", error);
                return [];
            }
        }

        async function loadAndArrangeCharms(items) {
            const count = items.length;
            if (count === 0) return;

            const angleStep = (Math.PI * 2) / count;

            for (let i = 0; i < count; i++) {
                const item = items[i];
                let modelUrl;
                let isLocal = false;
                let localId = null;
                let filename = '';

                if (item.type === 'db') {
                    const blob = new Blob([item.val.buffer], { type: 'application/octet-stream' });
                    modelUrl = URL.createObjectURL(blob);
                    isLocal = true;
                    localId = item.val.id;
                    filename = item.val.filename;
                } else {
                    modelUrl = item.val;
                    if (!modelUrl || modelUrl.includes('undefined')) continue;
                    filename = modelUrl.split('/').pop();
                }

                const model = await loadModelSmart(modelUrl);
                if (model) {
                    const angle = i * angleStep;

                    const pivot = new THREE.Group();
                    pivot.rotation.y = -angle;

                    const holder = new THREE.Group();
                    holder.position.set(BRACELET_RADIUS, 0, 0);

                    pivot.add(holder);

                    model.position.set(0, 0, 0);
                    model.rotation.y = Math.PI / 2;

                    model.userData = {
                        isCharm: true,
                        isLocal: isLocal,
                        localId: localId,
                        filename: filename
                    };

                    holder.add(model);
                    charmsGroup.add(pivot);
                    allCharmMeshes.push(model);
                }
            }
        }

        // --- STYLE SWITCHER ---
        window.switchStyle = function (style) {
            // If bright/default style, use null to show CSS gradient. Else use dark metal color.
            scene.background = (style === 'bright' ? null : new THREE.Color(0x111111));

            // Fog matches the Rose mid-tone (#E6C2C2) for smoother blending
            // Decreased density: Near=20, Far=90 (was 15, 60 implicitly)
            if (scene.fog) {
                scene.fog.color.set(style === 'bright' ? 0xE6C2C2 : 0x111111);
                scene.fog.near = 20;
                scene.fog.far = 90;
            }

            // Toggle Lights
            lights.bright.forEach(l => l.visible = (style === 'bright'));
            lights.metal.forEach(l => l.visible = (style === 'metal'));

            // Toggle Floor
            // Use Dark (#1A1A1A) for shadow plane to make white models pop against light background
            plane.material.color.set(style === 'bright' ? 0x1A1A1A : 0x333333);
            // Increase opacity for better contrast
            plane.material.opacity = style === 'bright' ? 0.4 : 0.5;
        };

        // --- INIT SEQUENCE ---
        async function init() {
            console.log("INIT STARTED");
            try {
                uiMsg.innerText = "Bƒ∞LEKLƒ∞K ƒ∞≈ûLENƒ∞YOR...";

                const brace = await loadMainBracelet();
                console.log("Main Bracelet Loaded:", brace);
                if (brace) console.log("Brace Children:", brace.children.length);

                uiMsg.innerText = "CHARMLAR HAZIRLANIYOR...";

                // Load Static Files (API)
                const staticFiles = await scanSourceFolder();
                console.log("Static Files found:", staticFiles);

                // Load Local DB Files (IndexedDB)
                const localCharms = await getCharmsFromDB();
                console.log("DB Charms found:", localCharms);

                const allItems = [
                    ...staticFiles.map(url => ({ type: 'url', val: url })),
                    ...localCharms.map(item => ({ type: 'db', val: item }))
                ];

                console.log("Total items to process:", allItems.length);
                console.log("Items:", JSON.stringify(allItems));

                if (allItems.length > 0) await loadAndArrangeCharms(allItems);

                console.log("Checking Scene:", scene.children);

                window.switchStyle('bright');
                uiMsg.innerText = "HAZIR!";
                console.log("INIT DONE");
                setTimeout(() => { uiLoading.style.opacity = 0; setTimeout(() => uiLoading.remove(), 500); }, 800);
            } catch (error) {
                console.error("INIT ERROR:", error);
                uiMsg.innerText = "HATA: " + error.message;
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Rotate main group slowly if autoRotate is on (optional custom logic)
            // if (controls.autoRotate) { ... } 

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        animate();
        init();
    </script>
</body>

</html>